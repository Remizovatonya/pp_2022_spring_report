
\documentclass{report}

\usepackage[warn]{mathtext}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{luainputenc}
\usepackage[english, russian]{babel}
\usepackage[pdftex]{hyperref}
\usepackage[12pt]{extsizes}
\usepackage{listings}
\usepackage{color}
\usepackage{geometry}
\usepackage{enumitem}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{amsmath}

\geometry{a4paper,top=2cm,bottom=2cm,left=2.5cm,right=1.5cm}
\setlength{\parskip}{0.5cm}
\setlist{nolistsep, itemsep=0.3cm,parsep=0pt}

\usepackage{listings}
\lstset{language=C++,
        basicstyle=\footnotesize,
		keywordstyle=\color{blue}\ttfamily,
		stringstyle=\color{red}\ttfamily,
		commentstyle=\color{green}\ttfamily,
		morecomment=[l][\color{red}]{\#}, 
		tabsize=4,
		breaklines=true,
  		breakatwhitespace=true,
  		title=\lstname,       
}

\begin{document}

\begin{titlepage}

\begin{center}
Министерство науки и высшего образования Российской Федерации
\end{center}

\begin{center}
Федеральное государственное автономное образовательное учреждение высшего образования \\
Национальный исследовательский Нижегородский государственный университет им. Н.И. Лобачевского
\end{center}

\begin{center}
Институт информационных технологий, математики и механики
\end{center}

\vspace{4em}

\begin{center}
\textbf{\LargeОтчет по лабораторной работе} \\
\end{center}
\begin{center}
\textbf{\Large«Сортировка Хоара с четно-нечетным слиянием Бэтчера.»} \\
\end{center}

\vspace{4em}

\newbox{\lbox}
\savebox{\lbox}{\hbox{text}}
\newlength{\maxl}
\setlength{\maxl}{\wd\lbox}
\hfill\parbox{7cm}{
\hspace*{5cm}\hspace*{-5cm}\textbf{Выполнила:} \\ студентка группы 381908-1 \\ Ремизова А. Р.\\
\\
\hspace*{5cm}\hspace*{-5cm}\textbf{Проверил:}\\ доцент кафедры МОСТ, \\ кандидат технических наук \\ Сысоев А. В.\\
}
\vspace{\fill}

\begin{center} Нижний Новгород \\ 2022 \end{center}

\end{titlepage}

\setcounter{page}{2}

% Содержание
\tableofcontents
\newpage

% Введение
\section*{Введение}
\addcontentsline{toc}{section}{Введение}
\par Алгоритмы сортировки данных широко используются в программировании для решения различных задач. Существует множество сортировок массивов (структур данных, которые хранят наборы значений), каждая из которых выполняет определенную задачу (работа с большими массивами, оптимизация по скорости, числу процессорных циклов и т.д.)
\par Одним из таких алгоритмов является сортировка Хоара, которую иначе называют быстрой сортировкой (quicksort). Ее изобрел английский ученый Чарльз Хоар в 1960 году. Суть данной сортировки заключается в выборе некоторого опорного элемента массива, относительно которого реорганизуется вся последовательность данных таким образом, чтобы все элементы меньше или равные опорному оказались слева от него, а большие - справа.
\par Еще один алгоритм, который нам понадобится - четно-нечетная сортировка слиянием Бэтчера (odd-even mergesort), который разработан Бэтчером в 1968 году. Его суть заключается в разделении массива на две половины по принципу четных и нечетных элементов, сортировке каждой половиный в отдельности и слиянии в один массив.
\newpage

% Постановка задачи
\section*{Постановка задачи}
\addcontentsline{toc}{section}{Постановка задачи}
\par Требуется выполнить следующие задачи:
\begin{enumerate}
    \item Реализовать последовательную версию программы с применением сортировки Хоара совместно с четно-нечетным слиянием Бэтчера
    \item Реализовать параллельные версии программы с использованием сортировки Хоара с четно-нечетным слиянием Бэтчера с использованием технологий OpenMP, Intel TBB и std::thread.
    \item Провести эксперименты для сравнения и оценки эффективности выполненных реализаций последовательной и параллельных программ.
\end{enumerate}
\par 
\newpage

% Описание алгоритма сортировки Хоара
\section*{Описание алгоритма}
\addcontentsline{toc}{section}{Описание алгоритма}
\par Алгоритм используется для одномерного массива чисел с целью его сортировки по возрастанию.
\par Сортировка Хоара:
\begin{enumerate}
  \item Исходный массив делится на два отдельных подмассива пополам, последующий алгоритм (описанный для одного массива) выполняется для каждого из полученных массивов.
  \item Длина образованного подмассива делится на 2 без остатка, полученное число является индексом опрного элемента pivot.
  \item Индекс l приравнивается к нулевому элементу массива, а индекс r к последнему элементу массива.
  \item Оба индекса смещаются на 1 к середине массива по очереди до тех пор, пока l не найдет элемент больший pivot, а r - меньший или равный pivot.
  \item В случае нахождения пары элементов по l и r, удовлетворяющих условию, описанному выше и l < r, элементы меняются местами, а проход по массиву продолжается с тех значений l и r, на которых остановился алгоритм.
  Следует учесть, что если какая-либо граница (l или r) дошла до опорного элемента, то при обмене значение pivot изменяется на r-й или l-й элемент соответственно.
  \item В момент, когда l = r, оба индекса указывают на опорный элемент, проход по массиву завершен, найдена середина массива. 
  \item Алгоритм рекурсивно применяется для полученных подмассивов, лежащих справа и слева от опорного элемента до тех пор, пока не будут упорядоченны подмасивы длиной 1 или 2 элемента.
  \item На выходе получаем два отсортированных по возрастанию массива, которые необходимо слить в исходный, в конечном упорядоченном виде, для этого воспользуемся четно-нечетным слиянием Бэтчера
\end{enumerate}
\newpage

% Описание алгоритма сортировки слиянием Бэтчера
\par Четно-нечетное слияние Бэтчера:
\begin{enumerate}
    \item Два упорядоченных соротировкой Хоара массива вновь реорганизуются в два новых массива таким образом, что все элементы, стоящие на четных позициях первого и второго массива записываются в новый массив (even), а все нечетные - в новый (odd).
    \item Во время перестраивания массивов, для even, производится сравнение элементов, стоящих на четных местах первого отсортированного хоаром массива с элементами, стоящими на четных местах второго отсортированного массива.
    В первую очередь сравниваются по значению элементы с нулевыми индексами, меньший из них записывается во вновь созданный массив even. В массиве с большим элементом индекс остается на месте, а с меньшим смещается на +2. Такм образом один из индексов дойдет до конца своего массива, после чего, все оставшиеся четные элементы другого массива необходимо записать в even по порядку возрастания индексов.
    \item Аналогичная схема происходит и для массива odd, с единственным отличием, что первой парой сравниваемых значений элементов массивов, являются элементы с индексами 1.
    \item После этого odd и even необходимо слить воедино так, чтобы все элементы четного массива встали в начало массива, а нечетного в конец.
    \item По итоговому массиву вновь необходимо пройти циклом со сравнением двух соседних элементов и, если элемент с меньшим индексом больше элемента с большим индексом, поменять их местами. На выходе мы получим полностью отсортированный исходный массив программы
\end{enumerate}
\newpage

% Описание схемы распараллеливания
\section*{Описание схемы распараллеливания}
\addcontentsline{toc}{section}{Описание схемы распараллеливания}
\par Распараллеливание происходит в два этапа. Первый - выполнение сортировки Хоара двух полученных из исходных массивов происходит на двух потоках, необходимо дождаться их завершения и получения результатов. Второй - сортировка Бэтчера. Полученные массивы передаются в методы четной и нечетной сортировки, которые также выполняются параллельно на двух потоках.
\par В случае использования технологии OpenMp для распараллеливания по секциям используется директива \textsl{\#pragma omp parallel sections}. После этой директивы программа разделяет код для распределения по потокам, каждый из которых выполняет отдельную выделенную директивой \textsl{\#pragma omp section} секцию. Такое распараллеливание возможно, поскольку между частями кода нет информационной зависимости, оно применяется дважды, для сортировки Хоара и сортировки Бэтчера, так как необходимо дождаться результатов первой сортировки массивов.
\par При использовании технологии Intel TBB для распараллеливания выполняемых методов, обернем их в два цикла. Для этого воспользуемся шаблонной функцией tbb::parallel\_for, где первый параметр - одномерное итерационное пространство tbb::blocked\_range, которое задает диапазон в виде полуинтервала по количеству исполняемых методов в данном цикле, второй параметр - лямбда-выражение, в котором через условие if определяется разделение выполняемых частей кода. Данная директива также применяется дважды длясортировки Хоара и сортировки Бэтчера.
\par При использовании std::thread, для каждого метода напрямую укажем создание потока, в котором он будет выолняться. Для этого воспользуемся вызовом из стандартной библиотеки std::async, которая позволяет выполнять некий код асинхронно. Первым параметром данной функции укажем std::launch::async, чтобы исполняемый код гарантированно выполнился в отдельном потоке. Вторым параметром укажем название метода, которое будет выполняться в данном потоке. После указания двух потоков для сортировки Хоара необходимо дождаться их выполнения с помощью метода wait(), после чего аналогично создаются еще два потока для сортировки Бэтчера, значения из которых необходимо получить с помощью метода get() для корректного выполнения дальнейшего кода программы. 
\newpage

% Описание программной реализации
\section*{Описание программной реализации}
\addcontentsline{toc}{section}{Описание программной реализации}
Программа содержит в себе заголовочный файл hoar\_batcher.h и два файла решения hoar\_batcher.cpp и main.cpp.
\par В заголовочном файле находятся прототипы функций для реализации последовательной и параллельной сортировок массива методами Хоара и Бэтчера, а также прототипы функций для генерации рандомных значений массива заданной длины, проверки коррректности сортировки массива и прототип функции, объединяющий все вышеупомянутые сортировки воедино со слиянием.
\par Генерация рандомных значений в указанном интервале для вектора заданной длины, которая передается в качестве параметра данного метода:
\begin{lstlisting}
std::vector<double> getRandVector(int size);
\end{lstlisting}
\par Метод возвращает сгенерированный вектор значений.
\par Проверка корректности сортировки массива по возрастанию значений элементов, в качестве пераметра передается константная ссылка на массив.
\begin{lstlisting}
bool isSortCorrectly(const std::vector <double>& vec);
\end{lstlisting}
\par Возвращает булевое значение в зависимости от результата проверки, true - в случае корректной сортировки и false - в ином случае.
\par Метод, рекурсивно реализующий сортировку Хоара. В качестве параметров передается указатель на массив, а также левая и правая границы массива для установления итераторов.
\begin{lstlisting}
void hoarSort(std::vector <double>* vec, int left, int right);
\end{lstlisting}
\par Метод не возвращает значение, все изменения происходят с массивом, переданным по указателю.
\par Четная и нечетная сортировки Бэтчера, принимают в себя две константные ссылки на массивы, отсортированные с помощью Хоара.
\begin{lstlisting}
std::vector<double> evenBatcherSort(const std::vector<double>& vec1, const std::vector<double>& vec2);
std::vector<double> oddBatcherSort(const std::vector<double>& vec1, const std::vector<double>& vec2);
\end{lstlisting}
\par Возвращают отсортированные векторы (с четными элементами и с нечетными).
\par Слияние двух полученных массивов в один, где первыми идут элементы четного массива, а после - нечетного, принимает в себя две константные ссылки на четно-нечетно отсортированные массивы.
\begin{lstlisting}
std::vector<double> oddEvenBatcherSort(const std::vector<double>& vec1, const std::vector<double>& vec2);
\end{lstlisting}
\par Возвращает вектор.
\par Слияние двух отсортированных частей воедино для получения конечного отсортированного массива. Принимает в себя константную ссылку на массив, полученный из предыдущего метода, а также индекс элемента, стоящего на границе разделения четных и нечетных элементов:
\begin{lstlisting}
std::vector<double> mergeBatcher(const std::vector<double>& vec, int middle);
\end{lstlisting}
\par Возвращает полностью отсортированный вектор.
\par Метод, вызывающий в себе все приведенные выше сортировки для последовательной реализации программы. Принимает константную ссылку на массив и размер массива:
\begin{lstlisting}
std::vector<double> hoarBatcherSeq(const std::vector<double>& vec, int size);
\end{lstlisting}
\par Возвращает отсротированный массив данных.
\par Метод, вызывающий в себе все приведенные выше сортировки для параллельной реализации программы с применением необходимых технологий, используемых для этого. Принимает в себя константную ссылку на массив и его размер:
\begin{lstlisting}
std::vector<double> hoarBatcherPar(const std::vector<double>& vec, int size);
\end{lstlisting}
\par Возвращает отсортированный массив данных.
\par В файле hoar\_batcher.cpp содержатся реализации методов, прописанных в файле hoar\_batcher.h. В файле main.cpp содержатся тесты для проверки корректности программы.
\newpage

% Подтверждение корректности
\section*{Подтверждение корректности}
\addcontentsline{toc}{section}{Подтверждение корректности}
Чтобы убедиться в корректности и правильности реализации программного кода, были написаны тесты с помощью фреймворка Google Test. Они содержат в себе проверку на правильность создания массивов с заданной длиной, корректность сортировки массива с помощью сортировки Хоара с четно-нечетным слиянием Бэтчера для рандомного вектора и для ветора со значениями элементов, равными нулю, а также для векторов четной и нечетной длины. Для параллельной реализации программы также были написаны тесты, которые проверяли корректность и время работы программы для массивов различной длины, сверяя результаты сортировки с помощью последовательного и параллельного методов. Все тесты были пройдены успешно. 
\newpage

% Результаты экспериментов
\section*{Результаты экспериментов}
\addcontentsline{toc}{section}{Результаты экспериментов}
\par Эксперименты для оценки эффективности проводились с использованием следующего оборудования и программного обеспечения:
\begin{itemize}
\item Процессор: Intel Core i5-1135G7 2,4 ГГц (8 МБ кеш-памяти, до 4,2 ГГц, 4 ядра);
\item Видеокарта: Intel Iris Xe Graphics;
\item Оперативная память: 8 ГБ DDR4 на плате, макс. объем: 8 ГБ;
\item Операционная система: Microsoft Windows 10;
\item Среда разработки, компилятор: Microsoft Visual Studio 2019, встроенный компилятор.
\end{itemize}
\par Тестирование проводилось для векторов с различной заданной длиной на 2 потоках.
\par Результаты тестирования выражены в таблицах.

\begin{table}[!h]
\caption{Результаты вычислительных экспериментов c массивом длиной 100}
\centering
\begin{tabular}{| p{5cm} | p{5cm} | p{5cm} |}
\hline
Версия алгоритма & Время работы & Ускорение  \\[5pt]
\hline
Sequential      & 0.0000356       & -             \\
OpenMP          & 0.000032        & 1.1125        \\
Intel TBB       & 0.0000348       & 1.02298       \\
std::thread     & 0.000           & -             \\
\hline
\end{tabular}
\end{table}

\begin{table}[!h]
\caption{Результаты вычислительных экспериментов c массивом длиной 10000}
\centering
\begin{tabular}{| p{5cm} | p{5cm} | p{5cm} |}
\hline
Версия алгоритма & Время работы & Ускорение  \\[5pt]
\hline
Sequential      & 0.0025558      & -            \\
OpenMP          & 0.0019382      & 1.31864      \\
Intel TBB       & 0.0018914      & 1.35127      \\
std::thread     & 0.002          & 1.2779       \\
\hline
\end{tabular}
\end{table}

\begin{table}[!h]
\caption{Результаты вычислительных экспериментов c массивом длиной 100000}
\centering
\begin{tabular}{| p{5cm} | p{5cm} | p{5cm} |}
\hline
Версия алгоритма & Время работы & Ускорение  \\[5pt]
\hline
Sequential      & 0.0323414      & -            \\
OpenMP          & 0.0220758      & 1.46501      \\
Intel TBB       & 0.0221485      & 1.4602       \\
std::thread     & 0.023          & 1.40615      \\
\hline
\end{tabular}
\end{table}

\begin{table}[!h]
\caption{Результаты вычислительных экспериментов c массивом длиной 1000000}
\centering
\begin{tabular}{| p{5cm} | p{5cm} | p{5cm} |}
\hline
Версия алгоритма & Время работы & Ускорение  \\[5pt]
\hline
Sequential      & 0.450901      & -            \\
OpenMP          & 0.259559      & 1.73718      \\
Intel TBB       & 0.225945      & 1.99562      \\
std::thread     & 0.245         & 1.84041      \\
\hline
\end{tabular}
\end{table}
\newpage

% Выводы из результатов экспериментов
\section*{Выводы из результатов экспериментов}
\addcontentsline{toc}{section}{Выводы из результатов экспериментов}
\par Результаты тестирования показали, что параллельная реализация программы дает достаточно эффективный результат в том случае, когда размеры массивов достаточно велики, в этом случае время выполнения сортировок превышает расходы, затрчиваемые на создание и управление потоками. Заметный результат появляется у массивов, размером в 10000 элементов или более. Также можно заметить, что время выполнения последовательной и параллельной сортировок могут зависеть от генерации исходного массива, так как в некоторых случаях, выполнение программы замедляется или ускоряется, что влияет на результаты экспериментальных данных. При проведении повторных тестирований появляются значения времени не совпадающие со среднем арифметическим аналогичных тестирований.
\newpage

% Заключение
\section*{Заключение}
\addcontentsline{toc}{section}{Заключение}
\par В ходе данной задачи были реализованы последовательная версия программы с применением сортировки Хоара с четно-нечетным слиянием Бэтчера, а также ее паралелльные версии с использованием технологий OpenMP, Intel TBB и std::thread.
Также были реализованы различные тесты, проверяющие корректность работы программы и реализации сортировок, а также измеряющие время выполнения кода для определения эффективности написанных версий.
\newpage

% Литература
\section*{Литература}
\addcontentsline{toc}{section}{Литература}
\begin{enumerate}
\item Сысоев А.В. Параллельное программирование с использованием OpenMP. URL: \newline
\url{https://cloud.unn.ru/s/RQMgkKLMq92cm6A}
\item Мееров И.Б., Сысоев А.В., Сиднев А.А. Инструменты параллельного программирования для систем с общей памятью. Библиотека Intel Threading Building Blocks. URL: \newline
\url{https://cloud.unn.ru/s/nS8EtaeH7N4XW7t}
\item Сортировка Хоара - Электронный ресурс. URL: \newline
\url{https://foxford.ru/wiki/informatika/bystraya-sortirovka-hoara?utm_referrer=https%3A%2F%2Fwww.google.com%2F}
\item Сортировка Бэтчера - Электронный ресурс. URL: \newline
\url{https://habr.com/ru/post/261777/}
\end{enumerate}
\newpage

% Приложение
\section*{Приложение}
\addcontentsline{toc}{section}{Приложение}
\textbf{Последовательная версия}
\par vert\_gaussian.h
\begin{lstlisting}
\end{lstlisting}
\end{document}