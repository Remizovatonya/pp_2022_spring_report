
\documentclass{report}

\usepackage[warn]{mathtext}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{luainputenc}
\usepackage[english, russian]{babel}
\usepackage[pdftex]{hyperref}
\usepackage[12pt]{extsizes}
\usepackage{listings}
\usepackage{color}
\usepackage{geometry}
\usepackage{enumitem}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{amsmath}

\geometry{a4paper,top=2cm,bottom=2cm,left=2.5cm,right=1.5cm}
\setlength{\parskip}{0.5cm}
\setlist{nolistsep, itemsep=0.3cm,parsep=0pt}

\usepackage{listings}
\lstset{language=C++,
        basicstyle=\footnotesize,
		keywordstyle=\color{blue}\ttfamily,
		stringstyle=\color{red}\ttfamily,
		commentstyle=\color{green}\ttfamily,
		morecomment=[l][\color{red}]{\#}, 
		tabsize=4,
		breaklines=true,
  		breakatwhitespace=true,
  		title=\lstname,       
}

\begin{document}

\begin{titlepage}

\begin{center}
Министерство науки и высшего образования Российской Федерации
\end{center}

\begin{center}
Федеральное государственное автономное образовательное учреждение высшего образования \\
Национальный исследовательский Нижегородский государственный университет им. Н.И. Лобачевского
\end{center}

\begin{center}
Институт информационных технологий, математики и механики
\end{center}

\vspace{4em}

\begin{center}
\textbf{\LargeОтчет по лабораторной работе} \\
\end{center}
\begin{center}
\textbf{\Large«Сортировка Хоара с четно-нечетным слиянием Бэтчера.»} \\
\end{center}

\vspace{4em}

\newbox{\lbox}
\savebox{\lbox}{\hbox{text}}
\newlength{\maxl}
\setlength{\maxl}{\wd\lbox}
\hfill\parbox{7cm}{
\hspace*{5cm}\hspace*{-5cm}\textbf{Выполнила:} \\ студентка группы 381908-1 \\ Ремизова А. Р.\\
\\
\hspace*{5cm}\hspace*{-5cm}\textbf{Проверил:}\\ доцент кафедры МОСТ, \\ кандидат технических наук \\ Сысоев А. В.\\
}
\vspace{\fill}

\begin{center} Нижний Новгород \\ 2022 \end{center}

\end{titlepage}

\setcounter{page}{2}

% Содержание
\tableofcontents
\newpage

% Введение
\section*{Введение}
\addcontentsline{toc}{section}{Введение}
\par Алгоритмы сортировки данных широко используются в программировании для решения различных задач. Существует множество сортировок массивов (структур данных, которые хранят наборы значений), каждая из которых выполняет определенную задачу (работа с большими массивами, оптимизация по скорости, числу процессорных циклов и т.д.)
\par Одним из таких алгоритмов является сортировка Хоара, которую иначе называют быстрой сортировкой (quicksort). Ее изобрел английский ученый Чарльз Хоар в 1960 году. Суть данной сортировки заключается в выборе некоторого опорного элемента массива, относительно которого реорганизуется вся последовательность данных таким образом, чтобы все элементы меньше или равные опорному оказались слева от него, а большие - справа.
\par Еще один алгоритм, который нам понадобится - четно-нечетная сортировка слиянием Бэтчера (odd-even mergesort), который разработан Бэтчером в 1968 году. Его суть заключается в разделении массива на две половины по принципу четных и нечетных элементов, сортировке каждой половиный в отдельности и слиянии в один массив.
\newpage

% Постановка задачи
\section*{Постановка задачи}
\addcontentsline{toc}{section}{Постановка задачи}
\par Требуется выполнить следующие задачи:
\begin{enumerate}
    \item Реализовать последовательную версию программы с применением сортировки Хоара совместно с четно-нечетным слиянием Бэтчера
    \item Реализовать параллельные версии программы с использованием сортировки Хоара с четно-нечетным слиянием Бэтчера с использованием технологий OpenMP, Intel TBB и std::thread.
    \item Провести эксперименты для сравнения и оценки эффективности выполненных реализаций последовательной и параллельных программ.
\end{enumerate}
\par 
\newpage

% Описание алгоритма сортировки Хоара
\section*{Описание алгоритма}
\addcontentsline{toc}{section}{Описание алгоритма}
\par Алгоритм используется для одномерного массива чисел с целью его сортировки по возрастанию.
\par Сортировка Хоара:
\begin{enumerate}
  \item Исходный массив делится на два отдельных подмассива пополам, последующий алгоритм (описанный для одного массива) выполняется для каждого из полученных массивов.
  \item Длина образованного подмассива делится на 2 без остатка, полученное число является индексом опрного элемента pivot.
  \item Индекс l приравнивается к нулевому элементу массива, а индекс r к последнему элементу массива.
  \item Оба индекса смещаются на 1 к середине массива по очереди до тех пор, пока l не найдет элемент больший pivot, а r - меньший или равный pivot.
  \item В случае нахождения пары элементов по l и r, удовлетворяющих условию, описанному выше и l < r, элементы меняются местами, а проход по массиву продолжается с тех значений l и r, на которых остановился алгоритм.
  Следует учесть, что если какая-либо граница (l или r) дошла до опорного элемента, то при обмене значение pivot изменяется на r-й или l-й элемент соответственно.
  \item В момент, когда l = r, оба индекса указывают на опорный элемент, проход по массиву завершен, найдена середина массива. 
  \item Алгоритм рекурсивно применяется для полученных подмассивов, лежащих справа и слева от опорного элемента до тех пор, пока не будут упорядоченны подмасивы длиной 1 или 2 элемента.
  \item На выходе получаем два отсортированных по возрастанию массива, которые необходимо слить в исходный, в конечном упорядоченном виде, для этого воспользуемся четно-нечетным слиянием Бэтчера
\end{enumerate}
\newpage

% Описание алгоритма сортировки слиянием Бэтчера
\par Четно-нечетное слияние Бэтчера:
\begin{enumerate}
    \item Два упорядоченных соротировкой Хоара массива вновь реорганизуются в два новых массива таким образом, что все элементы, стоящие на четных позициях первого и второго массива записываются в новый массив (even), а все нечетные - в новый (odd).
    \item Во время перестраивания массивов, для even, производится сравнение элементов, стоящих на четных местах первого отсортированного хоаром массива с элементами, стоящими на четных местах второго отсортированного массива.
    В первую очередь сравниваются по значению элементы с нулевыми индексами, меньший из них записывается во вновь созданный массив even. В массиве с большим элементом индекс остается на месте, а с меньшим смещается на +2. Такм образом один из индексов дойдет до конца своего массива, после чего, все оставшиеся четные элементы другого массива необходимо записать в even по порядку возрастания индексов.
    \item Аналогичная схема происходит и для массива odd, с единственным отличием, что первой парой сравниваемых значений элементов массивов, являются элементы с индексами 1.
    \item После этого odd и even необходимо слить воедино так, чтобы все элементы четного массива встали в начало массива, а нечетного в конец.
    \item По итоговому массиву вновь необходимо пройти циклом со сравнением двух соседних элементов и, если элемент с меньшим индексом больше элемента с большим индексом, поменять их местами. На выходе мы получим полностью отсортированный исходный массив программы
\end{enumerate}
\newpage

% Описание схемы распараллеливания
\section*{Описание схемы распараллеливания}
\addcontentsline{toc}{section}{Описание схемы распараллеливания}
\par Распараллеливание происходит в два этапа. Первый - выполнение сортировки Хоара двух полученных из исходных массивов происходит на двух потоках, необходимо дождаться их завершения и получения результатов. Второй - сортировка Бэтчера. Полученные массивы передаются в методы четной и нечетной сортировки, которые также выполняются параллельно на двух потоках.
\par В случае использования технологии OpenMp для распараллеливания по секциям используется директива \textsl{\#pragma omp parallel sections}. После этой директивы программа разделяет код для распределения по потокам, каждый из которых выполняет отдельную выделенную директивой \textsl{\#pragma omp section} секцию. Такое распараллеливание возможно, поскольку между частями кода нет информационной зависимости, оно применяется дважды, для сортировки Хоара и сортировки Бэтчера, так как необходимо дождаться результатов первой сортировки массивов.
\par При использовании технологии Intel TBB для распараллеливания выполняемых методов, обернем их в два цикла. Для этого воспользуемся шаблонной функцией tbb::parallel\_for, где первый параметр - одномерное итерационное пространство tbb::blocked\_range, которое задает диапазон в виде полуинтервала по количеству исполняемых методов в данном цикле, второй параметр - лямбда-выражение, в котором через условие if определяется разделение выполняемых частей кода. Данная директива также применяется дважды длясортировки Хоара и сортировки Бэтчера.
\par При использовании std::thread, для каждого метода напрямую укажем создание потока, в котором он будет выолняться. Для этого воспользуемся вызовом из стандартной библиотеки std::async, которая позволяет выполнять некий код асинхронно. Первым параметром данной функции укажем std::launch::async, чтобы исполняемый код гарантированно выполнился в отдельном потоке. Вторым параметром укажем название метода, которое будет выполняться в данном потоке. После указания двух потоков для сортировки Хоара необходимо дождаться их выполнения с помощью метода wait(), после чего аналогично создаются еще два потока для сортировки Бэтчера, значения из которых необходимо получить с помощью метода get() для корректного выполнения дальнейшего кода программы. 
\newpage

% Описание программной реализации
\section*{Описание программной реализации}
\addcontentsline{toc}{section}{Описание программной реализации}
Программа содержит в себе заголовочный файл hoar\_batcher.h и два файла решения hoar\_batcher.cpp и main.cpp.
\par В заголовочном файле находятся прототипы функций для реализации последовательной и параллельной сортировок массива методами Хоара и Бэтчера, а также прототипы функций для генерации рандомных значений массива заданной длины, проверки коррректности сортировки массива и прототип функции, объединяющий все вышеупомянутые сортировки воедино со слиянием.
\par Генерация рандомных значений в указанном интервале для вектора заданной длины, которая передается в качестве параметра данного метода:
\begin{lstlisting}
std::vector<double> getRandVector(int size);
\end{lstlisting}
\par Метод возвращает сгенерированный вектор значений.
\par Проверка корректности сортировки массива по возрастанию значений элементов, в качестве пераметра передается константная ссылка на массив.
\begin{lstlisting}
bool isSortCorrectly(const std::vector <double>& vec);
\end{lstlisting}
\par Возвращает булевое значение в зависимости от результата проверки, true - в случае корректной сортировки и false - в ином случае.
\par Метод, рекурсивно реализующий сортировку Хоара. В качестве параметров передается указатель на массив, а также левая и правая границы массива для установления итераторов.
\begin{lstlisting}
void hoarSort(std::vector <double>* vec, int left, int right);
\end{lstlisting}
\par Метод не возвращает значение, все изменения происходят с массивом, переданным по указателю.
\par Четная и нечетная сортировки Бэтчера, принимают в себя две константные ссылки на массивы, отсортированные с помощью Хоара.
\begin{lstlisting}
std::vector<double> evenBatcherSort(const std::vector<double>& vec1, const std::vector<double>& vec2);
std::vector<double> oddBatcherSort(const std::vector<double>& vec1, const std::vector<double>& vec2);
\end{lstlisting}
\par Возвращают отсортированные векторы (с четными элементами и с нечетными).
\par Слияние двух полученных массивов в один, где первыми идут элементы четного массива, а после - нечетного, принимает в себя две константные ссылки на четно-нечетно отсортированные массивы.
\begin{lstlisting}
std::vector<double> oddEvenBatcherSort(const std::vector<double>& vec1, const std::vector<double>& vec2);
\end{lstlisting}
\par Возвращает вектор.
\par Слияние двух отсортированных частей воедино для получения конечного отсортированного массива. Принимает в себя константную ссылку на массив, полученный из предыдущего метода, а также индекс элемента, стоящего на границе разделения четных и нечетных элементов:
\begin{lstlisting}
std::vector<double> mergeBatcher(const std::vector<double>& vec, int middle);
\end{lstlisting}
\par Возвращает полностью отсортированный вектор.
\par Метод, вызывающий в себе все приведенные выше сортировки для последовательной реализации программы. Принимает константную ссылку на массив и размер массива:
\begin{lstlisting}
std::vector<double> hoarBatcherSeq(const std::vector<double>& vec, int size);
\end{lstlisting}
\par Возвращает отсротированный массив данных.
\par Метод, вызывающий в себе все приведенные выше сортировки для параллельной реализации программы с применением необходимых технологий, используемых для этого. Принимает в себя константную ссылку на массив и его размер:
\begin{lstlisting}
std::vector<double> hoarBatcherPar(const std::vector<double>& vec, int size);
\end{lstlisting}
\par Возвращает отсортированный массив данных.
\par В файле hoar\_batcher.cpp содержатся реализации методов, прописанных в файле hoar\_batcher.h. В файле main.cpp содержатся тесты для проверки корректности программы.
\newpage

% Подтверждение корректности
\section*{Подтверждение корректности}
\addcontentsline{toc}{section}{Подтверждение корректности}
Чтобы убедиться в корректности и правильности реализации программного кода, были написаны тесты с помощью фреймворка Google Test. Они содержат в себе проверку на правильность создания массивов с заданной длиной, корректность сортировки массива с помощью сортировки Хоара с четно-нечетным слиянием Бэтчера для рандомного вектора и для ветора со значениями элементов, равными нулю, а также для векторов четной и нечетной длины. Для параллельной реализации программы также были написаны тесты, которые проверяли корректность и время работы программы для массивов различной длины, сверяя результаты сортировки с помощью последовательного и параллельного методов. Все тесты были пройдены успешно. 
\newpage

% Результаты экспериментов
\section*{Результаты экспериментов}
\addcontentsline{toc}{section}{Результаты экспериментов}
\par Эксперименты для оценки эффективности проводились с использованием следующего оборудования и программного обеспечения:
\begin{itemize}
\item Процессор: Intel Core i5-1135G7 2,4 ГГц (8 МБ кеш-памяти, до 4,2 ГГц, 4 ядра);
\item Видеокарта: Intel Iris Xe Graphics;
\item Оперативная память: 8 ГБ DDR4 на плате, макс. объем: 8 ГБ;
\item Операционная система: Microsoft Windows 10;
\item Среда разработки, компилятор: Microsoft Visual Studio 2019, встроенный компилятор.
\end{itemize}
\par Тестирование проводилось для векторов с различной заданной длиной на 4 потоках.
\par Результаты тестирования выражены в таблицах.

\begin{table}[!h]
\caption{Результаты вычислительных экспериментов c массивом длиной 100}
\centering
\begin{tabular}{| p{5cm} | p{5cm} | p{5cm} |}
\hline
Версия алгоритма & Время работы & Ускорение  \\[5pt]
\hline
Sequential      & 0.0000356       & -             \\
OpenMP          & 0.000032        & 1.1125        \\
Intel TBB       & 0.0000348       & 1.02298       \\
std::thread     & 0.000           & -             \\
\hline
\end{tabular}
\end{table}

\begin{table}[!h]
\caption{Результаты вычислительных экспериментов c массивом длиной 10000}
\centering
\begin{tabular}{| p{5cm} | p{5cm} | p{5cm} |}
\hline
Версия алгоритма & Время работы & Ускорение  \\[5pt]
\hline
Sequential      & 0.0025558      & -            \\
OpenMP          & 0.0019382      & 1.31864      \\
Intel TBB       & 0.0018914      & 1.35127      \\
std::thread     & 0.002          & 1.2779       \\
\hline
\end{tabular}
\end{table}

\begin{table}[!h]
\caption{Результаты вычислительных экспериментов c массивом длиной 100000}
\centering
\begin{tabular}{| p{5cm} | p{5cm} | p{5cm} |}
\hline
Версия алгоритма & Время работы & Ускорение  \\[5pt]
\hline
Sequential      & 0.0323414      & -            \\
OpenMP          & 0.0220758      & 1.46501      \\
Intel TBB       & 0.0221485      & 1.4602       \\
std::thread     & 0.023          & 1.40615      \\
\hline
\end{tabular}
\end{table}

\begin{table}[!h]
\caption{Результаты вычислительных экспериментов c массивом длиной 1000000}
\centering
\begin{tabular}{| p{5cm} | p{5cm} | p{5cm} |}
\hline
Версия алгоритма & Время работы & Ускорение  \\[5pt]
\hline
Sequential      & 0.450901      & -            \\
OpenMP          & 0.259559      & 1.73718      \\
Intel TBB       & 0.225945      & 1.99562      \\
std::thread     & 0.245         & 1.84041      \\
\hline
\end{tabular}
\end{table}
\newpage

% Выводы из результатов экспериментов
\section*{Выводы из результатов экспериментов}
\addcontentsline{toc}{section}{Выводы из результатов экспериментов}
\par Результаты тестирования показали, что параллельная реализация программы дает достаточно эффективный результат в том случае, когда размеры массивов достаточно велики, в этом случае время выполнения сортировок превышает расходы, затрчиваемые на создание и управление потоками. Заметный результат появляется у массивов, размером в 10000 элементов или более. Также можно заметить, что время выполнения последовательной и параллельной сортировок могут зависеть от генерации исходного массива, так как в некоторых случаях, выполнение программы замедляется или ускоряется, что влияет на результаты экспериментальных данных. При проведении повторных тестирований появляются значения времени не совпадающие со среднем арифметическим аналогичных тестирований.
\newpage

% Заключение
\section*{Заключение}
\addcontentsline{toc}{section}{Заключение}
\par В ходе данной задачи были реализованы последовательная версия программы с применением сортировки Хоара с четно-нечетным слиянием Бэтчера, а также ее паралелльные версии с использованием технологий OpenMP, Intel TBB и std::thread.
Также были реализованы различные тесты, проверяющие корректность работы программы и реализации сортировок, а также измеряющие время выполнения кода для определения эффективности написанных версий.
\newpage

% Литература
\section*{Литература}
\addcontentsline{toc}{section}{Литература}
\begin{enumerate}
\item Сысоев А.В. Параллельное программирование с использованием OpenMP. URL: \newline
\url{https://cloud.unn.ru/s/RQMgkKLMq92cm6A}
\item Мееров И.Б., Сысоев А.В., Сиднев А.А. Инструменты параллельного программирования для систем с общей памятью. Библиотека Intel Threading Building Blocks. URL: \newline
\url{https://cloud.unn.ru/s/nS8EtaeH7N4XW7t}
\item Сортировка Хоара - Электронный ресурс. URL: \newline
\url{https://foxford.ru/wiki/informatika/bystraya-sortirovka-hoara?utm_referrer=https%3A%2F%2Fwww.google.com%2F}
\item Сортировка Бэтчера - Электронный ресурс. URL: \newline
\url{https://habr.com/ru/post/261777/}
\end{enumerate}
\newpage

% Приложение
\section*{Приложение}
\addcontentsline{toc}{section}{Приложение}
\textbf{Последовательная версия}
\par hoar\_batcher.h
\begin{lstlisting}

// Copyright 2022 Remizova Antonina
#ifndef MODULES_TASK_1_REMIZOVA_A_HOAR_BATCHER_HOAR_BATCHER_H_
#define MODULES_TASK_1_REMIZOVA_A_HOAR_BATCHER_HOAR_BATCHER_H_

#include <random>
#include <vector>
#include <ctime>

std::vector<double> getRandVector(int size);
bool isSortCorrectly(const std::vector <double>& vec);
void hoarSort(std::vector <double>* vec, int left, int right);
std::vector<double> evenBatcherSort(const std::vector<double>& vec1, const std::vector<double>& vec2);
std::vector<double> oddBatcherSort(const std::vector<double>& vec1, const std::vector<double>& vec2);
std::vector<double> oddEvenBatcherSort(const std::vector<double>& vec1, const std::vector<double>& vec2);
std::vector<double> mergeBatcher(const std::vector<double>& vec, int middle);
std::vector<double> hoarBatcher(const std::vector<double>& vec, int size);

#endif  // MODULES_TASK_1_REMIZOVA_A_HOAR_BATCHER_HOAR_BATCHER_H_


\end{lstlisting}
\par hoar\_batcher.cpp
\begin{lstlisting}

// Copyright 2022 Remizova Antonina
#include "../../../modules/task_1/remizova_a_hoar_batcher/hoar_batcher.h"
#include <iostream>
#include <algorithm>
#include <random>
#include <vector>

std::vector<double> getRandVector(int size) {
    if (size < 0)
        throw "negative vector size";

    std::mt19937 gen((unsigned int)time(0));
    std::uniform_int_distribution <int> dist(-100000, 100000);
    std::vector <double> vec(size);
    for (int i = 0; i < size; i++) {
        vec[i] = dist(gen);
    }
    return vec;
}

bool isSortCorrectly(const std::vector <double>& vec) {
    bool sort = std::is_sorted(vec.begin(), vec.end());
    return sort;
}

void hoarSort(std::vector <double>* vec, int l_ind, int r_ind) {
    if (l_ind >= r_ind)
        return;

    int l = l_ind, r = r_ind;
    double pvt = vec->at((l + r) / 2);

    while (l <= r) {
        while (vec->at(l) < pvt)
            l++;
        while (vec->at(r) > pvt)
            r--;
        if (l <= r) {
            std::swap(vec->at(l), vec->at(r));
            l++;
            r--;
        }
    }

    if (l < r_ind)
        hoarSort(vec, l, r_ind);
    if (l_ind < r)
        hoarSort(vec, l_ind, r);

    return;
}

std::vector<double> evenBatcherSort(const std::vector<double>& vec1, const std::vector<double>& vec2) {
    const int size_v1 = vec1.size();
    const int size_v2 = vec2.size();
    int i = 0, j = 0, k = 0, l = 0;
    const int size_eres = vec1.size() / 2 + vec2.size() / 2 + vec1.size() % 2 + vec2.size() % 2;
    std::vector<double> eres(size_eres);
    for (; i < size_v1 && j < size_v2; k++) {
        if (vec1[i] <= vec2[j]) {
            eres[k] = vec1[i];
            i += 2;
        } else {
            eres[k] = vec2[j];
            j += 2;
        }
    }
    if (i >= size_v1) {
        for (l = j; l < size_v2; l += 2, k++)
            eres[k] = vec2[l];
    } else {
        for (l = i; l < size_v1; l += 2, k++)
            eres[k] = vec1[l];
    }

    return eres;
}

std::vector<double> oddBatcherSort(const std::vector<double>& vec1, const std::vector<double>& vec2) {
    const int size_v1 = vec1.size();
    const int size_v2 = vec2.size();
    int i = 1, j = 1, k = 0, l = 0;
    const int size_ores = vec1.size() / 2 + vec2.size() / 2;
    std::vector<double> ores(size_ores);
    for (; i < size_v1 && j < size_v2; k++) {
        if (vec1[i] <= vec2[j]) {
            ores[k] = vec1[i];
            i += 2;
        } else {
            ores[k] = vec2[j];
            j += 2;
        }
    }
    if (i >= size_v1) {
        for (l = j; l < size_v2; l += 2, k++)
            ores[k] = vec2[l];
    } else {
        for (l = i; l < size_v1; l += 2, k++)
            ores[k] = vec1[l];
    }

    return ores;
}

std::vector<double> oddEvenBatcherSort(const std::vector<double>& vec1, const std::vector<double>& vec2) {
    int size_oeres = vec1.size() + vec2.size();
    std::vector<double> oeres(size_oeres);

    for (size_t i = 0; i < vec1.size(); i++)
        oeres[i] = vec1[i];

    for (int i = vec1.size(), j = 0; i < size_oeres; i++, j++)
        oeres[i] = vec2[j];

    return oeres;
}

std::vector<double> mergeBatcher(const std::vector<double>& vec, int middle) {
    int size_res = vec.size();
    std::vector <double> res(size_res);
    int buf;

    for (int i = 0; i < size_res - middle; i++) {
        res[i * 2] = vec[i];
        res[i * 2 + 1] = vec[middle + i];
    }

    if (middle * 2 - size_res >= 1)
        res[size_res - 1] = vec[middle - 1];

    if (middle * 2 - size_res == 2)
        res[size_res - 2] = vec[middle - 2];

    for (int i = 1; i < size_res; i++) {
        if (res[i] < res[i - 1]) {
            buf = res[i - 1];
            res[i - 1] = res[i];
            res[i] = buf;
        }
    }

    return res;
}

std::vector<double> hoarBatcher(const std::vector<double>& vec, int size) {
    int k = size / 2;
    std::vector<double> vec1;
    vec1.assign(vec.begin(), vec.end() - k);
    std::vector<double> vec2;
    hoarSort(&vec1, 0, vec1.size() - 1);
    vec2.assign(vec.end() - k, vec.end());
    hoarSort(&vec2, 0, vec2.size() - 1);
    std::vector<double>even = evenBatcherSort(vec1, vec2);
    std::vector<double>odd = oddBatcherSort(vec1, vec2);
    std::vector<double>res_oe = oddEvenBatcherSort(even, odd);
    std::vector<double>sort_res = mergeBatcherSeq(res_oe, even.size());
    return sort_res;
}

\end{lstlisting}
\par main.cpp
\begin{lstlisting}

// Copyright 2022 Remizova Antonina
#include <gtest/gtest.h>
#include "../../../modules/task_1/remizova_a_hoar_batcher/hoar_batcher.h"

TEST(SEQ_hoar_batcher, can_create_rand_vec_10) {
    int size = 10;

    EXPECT_NO_THROW(getRandVector(size));
}

TEST(SEQ_hoar_batcher, can_create_rand_vec_10000) {
    int size = 10000;

    EXPECT_NO_THROW(getRandVector(size));
}

TEST(SEQ_hoar_batcher, can_not_create_rand_vec_with_negative_size) {
    int size = -10;

    EXPECT_ANY_THROW(getRandVector(size));
}

TEST(SEQ_hoar_batcher, can_hoar_sort_rand_vec) {
    int size = 231;
    std::vector<double> v = getRandVector(size);
    hoarSort(&v, 0, size - 1);
    EXPECT_EQ(1, isSortCorrectly(v));
}

TEST(SEQ_hoar_batcher, can_hoar_batcher_sort_zero_vec) {
    std::vector<double> v{ 0, 0, 1, 0, 0, 0, 0, 0 };
    int size = v.size();
    std::vector<double> res = hoarBatcherSeq(v, size);
    EXPECT_EQ(1, isSortCorrectly(res));
}

TEST(SEQ_hoar_batcher, can_hoar_batcher_sort_vec_with_even_size) {
    int size = 400;
    std::vector<double> v = getRandVector(size);
    std::vector<double> res = hoarBatcherSeq(v, v.size());
    EXPECT_EQ(1, isSortCorrectly(res));
}

TEST(SEQ_hoar_batcher, can_hoar_batcher_sort_vec_with_odd_size) {
    int size = 1331;
    std::vector<double> v = getRandVector(size);
    std::vector<double> res = hoarBatcherSeq(v, v.size());
    EXPECT_EQ(1, isSortCorrectly(res));
}

TEST(SEQ_hoar_batcher, can_hoar_batcher_sort_vec_with_double_elem) {
    int size = 9081;
    std::vector<double> v = getRandVector(size);
    v[740] = 4.5691;
    v[2943] = -17.89;
    std::vector<double> res = hoarBatcherSeq(v, v.size());
    EXPECT_EQ(1, isSortCorrectly(res));
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}

\end{lstlisting}
\newpage

\textbf{OpenMP версия}
\par hoar\_batcher.h
\begin{lstlisting}

// Copyright 2022 Remizova Antonina
#ifndef MODULES_TASK_2_REMIZOVA_A_HOAR_BATCHER_HOAR_BATCHER_H_
#define MODULES_TASK_2_REMIZOVA_A_HOAR_BATCHER_HOAR_BATCHER_H_

#include <omp.h>
#include <random>
#include <vector>

std::vector<double> getRandVector(int size);
bool isSortCorrectly(const std::vector <double>& vec);
void hoarSort(std::vector <double>* vec, int left, int right);
std::vector<double> evenBatcherSort(const std::vector<double>& vec1, const std::vector<double>& vec2);
std::vector<double> oddBatcherSort(const std::vector<double>& vec1, const std::vector<double>& vec2);
std::vector<double> oddEvenBatcherSort(const std::vector<double>& vec1, const std::vector<double>& vec2);
std::vector<double> mergeBatcher(const std::vector<double>& vec, int middle);
std::vector<double> hoarBatcherSeq(const std::vector<double>& vec, int size);
std::vector<double> hoarBatcherPar(const std::vector<double>& vec, int size);

#endif  // MODULES_TASK_2_REMIZOVA_A_HOAR_BATCHER_HOAR_BATCHER_H_

\end{lstlisting}
\par hoar\_batcher.cpp
\begin{lstlisting}

// Copyright 2022 Remizova Antonina
#include "../../../modules/task_2/remizova_a_hoar_batcher/hoar_batcher.h"
#include <iostream>
#include <algorithm>
#include <random>
#include <vector>

std::vector<double> getRandVector(int size) {
    if (size < 0)
        throw "negative vector size";

    std::mt19937 gen((unsigned int)time(0));
    std::uniform_int_distribution <int> dist(-100000, 100000);
    std::vector <double> vec(size);
    for (int i = 0; i < size; i++) {
        vec[i] = dist(gen);
    }
    return vec;
}

bool isSortCorrectly(const std::vector <double>& vec) {
    bool sort = std::is_sorted(vec.begin(), vec.end());
    return sort;
}

void hoarSort(std::vector <double>* vec, int l_ind, int r_ind) {
    if (l_ind >= r_ind)
        return;

    int l = l_ind, r = r_ind;
    double pvt = vec->at((l + r) / 2);

    while (l <= r) {
        while (vec->at(l) < pvt)
            l++;
        while (vec->at(r) > pvt)
            r--;
        if (l <= r) {
            std::swap(vec->at(l), vec->at(r));
            l++;
            r--;
        }
    }

    if (l < r_ind)
        hoarSort(vec, l, r_ind);
    if (l_ind < r)
        hoarSort(vec, l_ind, r);

    return;
}

std::vector<double> evenBatcherSort(const std::vector<double>& vec1, const std::vector<double>& vec2) {
    const int size_v1 = vec1.size();
    const int size_v2 = vec2.size();
    int i = 0, j = 0, k = 0, l = 0;
    const int size_eres = vec1.size() / 2 + vec2.size() / 2 + vec1.size() % 2 + vec2.size() % 2;
    std::vector<double> eres(size_eres);
    for (; i < size_v1 && j < size_v2; k++) {
        if (vec1[i] <= vec2[j]) {
            eres[k] = vec1[i];
            i += 2;
        } else {
            eres[k] = vec2[j];
            j += 2;
        }
    }
    if (i >= size_v1) {
        for (l = j; l < size_v2; l += 2, k++)
            eres[k] = vec2[l];
    } else {
        for (l = i; l < size_v1; l += 2, k++)
            eres[k] = vec1[l];
    }

    return eres;
}

std::vector<double> oddBatcherSort(const std::vector<double>& vec1, const std::vector<double>& vec2) {
    const int size_v1 = vec1.size();
    const int size_v2 = vec2.size();
    int i = 1, j = 1, k = 0, l = 0;
    const int size_ores = vec1.size() / 2 + vec2.size() / 2;
    std::vector<double> ores(size_ores);
    for (; i < size_v1 && j < size_v2; k++) {
        if (vec1[i] <= vec2[j]) {
            ores[k] = vec1[i];
            i += 2;
        } else {
            ores[k] = vec2[j];
            j += 2;
        }
    }
    if (i >= size_v1) {
        for (l = j; l < size_v2; l += 2, k++)
            ores[k] = vec2[l];
    } else {
        for (l = i; l < size_v1; l += 2, k++)
            ores[k] = vec1[l];
    }

    return ores;
}

std::vector<double> oddEvenBatcherSort(const std::vector<double>& vec1, const std::vector<double>& vec2) {
    int size_oeres = vec1.size() + vec2.size();
    std::vector<double> oeres(size_oeres);

    for (size_t i = 0; i < vec1.size(); i++)
        oeres[i] = vec1[i];

    for (int i = vec1.size(), j = 0; i < size_oeres; i++, j++)
        oeres[i] = vec2[j];

    return oeres;
}

std::vector<double> mergeBatcher(const std::vector<double>& vec, int middle) {
    int size_res = vec.size();
    std::vector <double> res(size_res);
    int buf;

    for (int i = 0; i < size_res - middle; i++) {
        res[i * 2] = vec[i];
        res[i * 2 + 1] = vec[middle + i];
    }

    if (middle * 2 - size_res >= 1)
        res[size_res - 1] = vec[middle - 1];

    if (middle * 2 - size_res == 2)
        res[size_res - 2] = vec[middle - 2];

    for (int i = 1; i < size_res; i++) {
        if (res[i] < res[i - 1]) {
            buf = res[i - 1];
            res[i - 1] = res[i];
            res[i] = buf;
        }
    }

    return res;
}

std::vector<double> hoarBatcherSeq(const std::vector<double>& vec, int size) {
    int k = size / 2;
    std::vector<double> vec1;
    vec1.assign(vec.begin(), vec.end() - k);
    std::vector<double> vec2;
    hoarSort(&vec1, 0, vec1.size() - 1);
    vec2.assign(vec.end() - k, vec.end());
    hoarSort(&vec2, 0, vec2.size() - 1);
    std::vector<double>even = evenBatcherSort(vec1, vec2);
    std::vector<double>odd = oddBatcherSort(vec1, vec2);
    std::vector<double>res_oe = oddEvenBatcherSort(even, odd);
    std::vector<double>sort_res = mergeBatcher(res_oe, even.size());
    return sort_res;
}

std::vector<double> hoarBatcherPar(const std::vector<double>& vec, int size) {
    int k = size / 2;
    std::vector<double> vec1;
    vec1.assign(vec.begin(), vec.end() - k);
    std::vector<double> vec2;
    vec2.assign(vec.end() - k, vec.end());
    std::vector<double>even;
    std::vector<double>odd;
#pragma omp parallel sections
    {
#pragma omp section
        {
            hoarSort(&vec1, 0, vec1.size() - 1);
        }

#pragma omp section
        {
            hoarSort(&vec2, 0, vec2.size() - 1);
        }
    }

#pragma omp parallel sections
    {
#pragma omp section
        {
            even = evenBatcherSort(vec1, vec2);
        }

#pragma omp section
        {
            odd = oddBatcherSort(vec1, vec2);
        }
    }

    std::vector<double>res_oe = oddEvenBatcherSort(even, odd);
    std::vector<double>sort_res = mergeBatcher(res_oe, even.size());
    return sort_res;
}

\end{lstlisting}
\par main.cpp
\begin{lstlisting}

// Copyright 2022 Remizova Antonina
#include <gtest/gtest.h>
#include "../../../modules/task_2/remizova_a_hoar_batcher/hoar_batcher.h"

TEST(SEQ_hoar_batcher, can_create_rand_vec_10) {
    int size = 10;

    EXPECT_NO_THROW(getRandVector(size));
}

TEST(SEQ_hoar_batcher, can_create_rand_vec_10000) {
    int size = 10000;

    EXPECT_NO_THROW(getRandVector(size));
}

TEST(SEQ_hoar_batcher, can_not_create_rand_vec_with_negative_size) {
    int size = -10;

    EXPECT_ANY_THROW(getRandVector(size));
}

TEST(SEQ_hoar_batcher, can_hoar_sort_rand_vec) {
    int size = 231;
    std::vector<double> v = getRandVector(size);
    hoarSort(&v, 0, size - 1);
    EXPECT_EQ(1, isSortCorrectly(v));
}

TEST(SEQ_hoar_batcher, can_hoar_batcher_sort_zero_vec) {
    std::vector<double> v{ 0, 0, 1, 0, 0, 0, 0, 0 };
    int size = v.size();
    std::vector<double> res = hoarBatcherSeq(v, size);
    EXPECT_EQ(1, isSortCorrectly(res));
}

TEST(SEQ_hoar_batcher, can_hoar_batcher_sort_vec_with_even_size) {
    int size = 400;
    std::vector<double> v = getRandVector(size);
    std::vector<double> res = hoarBatcherSeq(v, v.size());
    EXPECT_EQ(1, isSortCorrectly(res));
}

TEST(SEQ_hoar_batcher, can_hoar_batcher_sort_vec_with_odd_size) {
    int size = 1331;
    std::vector<double> v = getRandVector(size);
    std::vector<double> res = hoarBatcherSeq(v, v.size());
    EXPECT_EQ(1, isSortCorrectly(res));
}

TEST(SEQ_hoar_batcher, can_hoar_batcher_sort_vec_with_double_elem) {
    int size = 9081;
    std::vector<double> v = getRandVector(size);
    v[740] = 4.5691;
    v[2943] = -17.89;
    std::vector<double> res = hoarBatcherSeq(v, v.size());
    EXPECT_EQ(1, isSortCorrectly(res));
}

//  parallel part

TEST(PAR_hoar_batcher, can_hoar_batcher_sort_zero_vec) {
    std::vector<double> v{ 0, 0, 1, 0, 0, 0, 0, 0 };
    int size = v.size();
    std::vector<double> res = hoarBatcherPar(v, size);
    EXPECT_EQ(1, isSortCorrectly(res));
}

TEST(PAR_hoar_batcher, can_hoar_batcher_sort_vec_with_even_size) {
    int size = 400;
    std::vector<double> v = getRandVector(size);
    std::vector<double> res = hoarBatcherPar(v, v.size());
    EXPECT_EQ(1, isSortCorrectly(res));
}

TEST(PAR_hoar_batcher, can_hoar_batcher_sort_vec_with_odd_size) {
    int size = 1331;
    std::vector<double> v = getRandVector(size);
    std::vector<double> res = hoarBatcherPar(v, v.size());
    EXPECT_EQ(1, isSortCorrectly(res));
}

TEST(PAR_hoar_batcher, can_hoar_batcher_sort_vec_with_double_elem) {
    int size = 9081;
    std::vector<double> v = getRandVector(size);
    v[740] = 4.5691;
    v[2943] = -17.89;
    std::vector<double> res = hoarBatcherPar(v, v.size());
    EXPECT_EQ(1, isSortCorrectly(res));
}

TEST(PAR_hoar_batcher, compare_seq_seq_sort_with_vec_size_100) {
    int size = 100;
    std::vector<double> v = getRandVector(size);

    double start_time, seq_time, par_time;
    start_time = omp_get_wtime();
    std::vector<double> res_seq = hoarBatcherSeq(v, v.size());
    seq_time = omp_get_wtime() - start_time;

    start_time = omp_get_wtime();
    std::vector<double> res_par = hoarBatcherPar(v, v.size());
    par_time = omp_get_wtime() - start_time;

    std::cout << "res: " << par_time / seq_time;
    std::cout << " par: " << par_time;
    std::cout << " seq: " << seq_time;

    EXPECT_EQ(res_seq, res_par);
}

TEST(PAR_hoar_batcher, compare_seq_par_sort_with_vec_size_10000) {
    int size = 10000;
    std::vector<double> v = getRandVector(size);

    double start_time, seq_time, par_time;
    start_time = omp_get_wtime();
    std::vector<double> res_seq = hoarBatcherSeq(v, v.size());
    seq_time = omp_get_wtime() - start_time;

    start_time = omp_get_wtime();
    std::vector<double> res_par = hoarBatcherPar(v, v.size());
    par_time = omp_get_wtime() - start_time;

    std::cout << "res: " << par_time / seq_time;
    std::cout << " par: " << par_time;
    std::cout << " seq: " << seq_time;

    EXPECT_EQ(res_seq, res_par);
}

TEST(PAR_hoar_batcher, compare_seq_par_sort_with_vec_size_100000) {
    int size = 100000;
    std::vector<double> v = getRandVector(size);

    double start_time, seq_time, par_time;
    start_time = omp_get_wtime();
    std::vector<double> res_seq = hoarBatcherSeq(v, v.size());
    seq_time = omp_get_wtime() - start_time;

    start_time = omp_get_wtime();
    std::vector<double> res_par = hoarBatcherPar(v, v.size());
    par_time = omp_get_wtime() - start_time;

    std::cout << "res: " << par_time / seq_time;
    std::cout << " par: " << par_time;
    std::cout << " seq: " << seq_time;

    EXPECT_EQ(res_seq, res_par);
}

TEST(PAR_hoar_batcher, compare_seq_par_sort_with_vec_size_1000000) {
    int size = 1000000;
    std::vector<double> v = getRandVector(size);

    double start_time, seq_time, par_time;
    start_time = omp_get_wtime();
    std::vector<double> res_seq = hoarBatcherSeq(v, v.size());
    seq_time = omp_get_wtime() - start_time;

    start_time = omp_get_wtime();
    std::vector<double> res_par = hoarBatcherPar(v, v.size());
    par_time = omp_get_wtime() - start_time;

    std::cout << "res: " << par_time / seq_time;
    std::cout << " par: " << par_time;
    std::cout << " seq: " << seq_time;

    EXPECT_EQ(res_seq, res_par);
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}

\end{lstlisting}
\newpage

\textbf{TBB версия}
\par hoar\_batcher.h
\begin{lstlisting}

// Copyright 2022 Remizova Antonina
#ifndef MODULES_TASK_3_REMIZOVA_A_HOAR_BATCHER_HOAR_BATCHER_H_
#define MODULES_TASK_3_REMIZOVA_A_HOAR_BATCHER_HOAR_BATCHER_H_

#include <tbb/tbb.h>
#include <random>
#include <vector>

std::vector<double> getRandVector(int size);
bool isSortCorrectly(const std::vector <double>& vec);
void hoarSort(std::vector <double>* vec, int left, int right);
std::vector<double> evenBatcherSort(const std::vector<double>& vec1, const std::vector<double>& vec2);
std::vector<double> oddBatcherSort(const std::vector<double>& vec1, const std::vector<double>& vec2);
std::vector<double> oddEvenBatcherSort(const std::vector<double>& vec1, const std::vector<double>& vec2);
std::vector<double> mergeBatcher(const std::vector<double>& vec, int middle);
std::vector<double> hoarBatcherSeq(const std::vector<double>& vec, int size);
std::vector<double> hoarBatcherPar(const std::vector<double>& vec, int size);

#endif  // MODULES_TASK_3_REMIZOVA_A_HOAR_BATCHER_HOAR_BATCHER_H_

\end{lstlisting}
\par hoar\_batcher.h
\begin{lstlisting}

// Copyright 2022 Remizova Antonina
#include "../../../modules/task_3/remizova_a_hoar_batcher/hoar_batcher.h"
#include <iostream>
#include <algorithm>
#include <random>
#include <vector>

std::vector<double> getRandVector(int size) {
    if (size < 0)
        throw "negative vector size";

    std::mt19937 gen((unsigned int)time(0));
    std::uniform_int_distribution <int> dist(-100000, 100000);
    std::vector <double> vec(size);
    for (int i = 0; i < size; i++) {
        vec[i] = dist(gen);
    }
    return vec;
}

bool isSortCorrectly(const std::vector <double>& vec) {
    bool sort = std::is_sorted(vec.begin(), vec.end());
    return sort;
}

void hoarSort(std::vector <double>* vec, int l_ind, int r_ind) {
    if (l_ind >= r_ind)
        return;

    int l = l_ind, r = r_ind;
    double pvt = vec->at((l + r) / 2);

    while (l <= r) {
        while (vec->at(l) < pvt)
            l++;
        while (vec->at(r) > pvt)
            r--;
        if (l <= r) {
            std::swap(vec->at(l), vec->at(r));
            l++;
            r--;
        }
    }

    if (l < r_ind)
        hoarSort(vec, l, r_ind);
    if (l_ind < r)
        hoarSort(vec, l_ind, r);

    return;
}

std::vector<double> evenBatcherSort(const std::vector<double>& vec1, const std::vector<double>& vec2) {
    const int size_v1 = vec1.size();
    const int size_v2 = vec2.size();
    int i = 0, j = 0, k = 0, l = 0;
    const int size_eres = vec1.size() / 2 + vec2.size() / 2 + vec1.size() % 2 + vec2.size() % 2;
    std::vector<double> eres(size_eres);
    for (; i < size_v1 && j < size_v2; k++) {
        if (vec1[i] <= vec2[j]) {
            eres[k] = vec1[i];
            i += 2;
        } else {
            eres[k] = vec2[j];
            j += 2;
        }
    }
    if (i >= size_v1) {
        for (l = j; l < size_v2; l += 2, k++)
            eres[k] = vec2[l];
    } else {
        for (l = i; l < size_v1; l += 2, k++)
            eres[k] = vec1[l];
    }

    return eres;
}

std::vector<double> oddBatcherSort(const std::vector<double>& vec1, const std::vector<double>& vec2) {
    const int size_v1 = vec1.size();
    const int size_v2 = vec2.size();
    int i = 1, j = 1, k = 0, l = 0;
    const int size_ores = vec1.size() / 2 + vec2.size() / 2;
    std::vector<double> ores(size_ores);
    for (; i < size_v1 && j < size_v2; k++) {
        if (vec1[i] <= vec2[j]) {
            ores[k] = vec1[i];
            i += 2;
        } else {
            ores[k] = vec2[j];
            j += 2;
        }
    }
    if (i >= size_v1) {
        for (l = j; l < size_v2; l += 2, k++)
            ores[k] = vec2[l];
    } else {
        for (l = i; l < size_v1; l += 2, k++)
            ores[k] = vec1[l];
    }

    return ores;
}

std::vector<double> oddEvenBatcherSort(const std::vector<double>& vec1, const std::vector<double>& vec2) {
    int size_oeres = vec1.size() + vec2.size();
    std::vector<double> oeres(size_oeres);

    for (size_t i = 0; i < vec1.size(); i++)
        oeres[i] = vec1[i];

    for (int i = vec1.size(), j = 0; i < size_oeres; i++, j++)
        oeres[i] = vec2[j];

    return oeres;
}

std::vector<double> mergeBatcher(const std::vector<double>& vec, int middle) {
    int size_res = vec.size();
    std::vector <double> res(size_res);
    int buf;

    for (int i = 0; i < size_res - middle; i++) {
        res[i * 2] = vec[i];
        res[i * 2 + 1] = vec[middle + i];
    }

    if (middle * 2 - size_res >= 1)
        res[size_res - 1] = vec[middle - 1];

    if (middle * 2 - size_res == 2)
        res[size_res - 2] = vec[middle - 2];

    for (int i = 1; i < size_res; i++) {
        if (res[i] < res[i - 1]) {
            buf = res[i - 1];
            res[i - 1] = res[i];
            res[i] = buf;
        }
    }

    return res;
}

std::vector<double> hoarBatcherSeq(const std::vector<double>& vec, int size) {
    int k = size / 2;
    std::vector<double> vec1;
    vec1.assign(vec.begin(), vec.end() - k);
    std::vector<double> vec2;
    hoarSort(&vec1, 0, vec1.size() - 1);
    vec2.assign(vec.end() - k, vec.end());
    hoarSort(&vec2, 0, vec2.size() - 1);
    std::vector<double>even = evenBatcherSort(vec1, vec2);
    std::vector<double>odd = oddBatcherSort(vec1, vec2);
    std::vector<double>res_oe = oddEvenBatcherSort(even, odd);
    std::vector<double>sort_res = mergeBatcher(res_oe, even.size());
    return sort_res;
}

std::vector<double> hoarBatcherPar(const std::vector<double>& vec, int size) {
    int k = size / 2;
    std::vector<double> vec1;
    vec1.assign(vec.begin(), vec.end() - k);
    std::vector<double> vec2;
    vec2.assign(vec.end() - k, vec.end());
    std::vector<double>even;
    std::vector<double>odd;

    tbb::parallel_for(tbb::blocked_range<int>(0, 2),
        [&](tbb::blocked_range<int> r) {
            for (int i = r.begin(); i < r.end(); ++i) {
                if (i == 0)
                    hoarSort(&vec1, 0, vec1.size() - 1);
                else
                    hoarSort(&vec2, 0, vec2.size() - 1);
            }
        });

    tbb::parallel_for(tbb::blocked_range<int>(0, 2),
        [&](tbb::blocked_range<int> r) {
            for (int i = r.begin(); i < r.end(); ++i) {
                if (i == 0)
                    even = evenBatcherSort(vec1, vec2);
                else
                    odd = oddBatcherSort(vec1, vec2);
            }
        });

    std::vector<double>res_oe = oddEvenBatcherSort(even, odd);
    std::vector<double>sort_res = mergeBatcher(res_oe, even.size());
    return sort_res;
}

\end{lstlisting}
\par main.cpp
\begin{lstlisting}

// Copyright 2022 Remizova Antonina
#include <gtest/gtest.h>
#include <omp.h>
#include "../../../modules/task_3/remizova_a_hoar_batcher/hoar_batcher.h"

TEST(SEQ_hoar_batcher, can_create_rand_vec_10) {
    int size = 10;

    EXPECT_NO_THROW(getRandVector(size));
}

TEST(SEQ_hoar_batcher, can_create_rand_vec_10000) {
    int size = 10000;

    EXPECT_NO_THROW(getRandVector(size));
}

TEST(SEQ_hoar_batcher, can_not_create_rand_vec_with_negative_size) {
    int size = -10;

    EXPECT_ANY_THROW(getRandVector(size));
}

TEST(SEQ_hoar_batcher, can_hoar_sort_rand_vec) {
    int size = 231;
    std::vector<double> v = getRandVector(size);
    hoarSort(&v, 0, size - 1);
    EXPECT_EQ(1, isSortCorrectly(v));
}

TEST(SEQ_hoar_batcher, can_hoar_batcher_sort_zero_vec) {
    std::vector<double> v{ 0, 0, 1, 0, 0, 0, 0, 0 };
    int size = v.size();
    std::vector<double> res = hoarBatcherSeq(v, size);
    EXPECT_EQ(1, isSortCorrectly(res));
}

TEST(SEQ_hoar_batcher, can_hoar_batcher_sort_vec_with_even_size) {
    int size = 400;
    std::vector<double> v = getRandVector(size);
    std::vector<double> res = hoarBatcherSeq(v, v.size());
    EXPECT_EQ(1, isSortCorrectly(res));
}

TEST(SEQ_hoar_batcher, can_hoar_batcher_sort_vec_with_odd_size) {
    int size = 1331;
    std::vector<double> v = getRandVector(size);
    std::vector<double> res = hoarBatcherSeq(v, v.size());
    EXPECT_EQ(1, isSortCorrectly(res));
}

TEST(SEQ_hoar_batcher, can_hoar_batcher_sort_vec_with_double_elem) {
    int size = 9081;
    std::vector<double> v = getRandVector(size);
    v[740] = 4.5691;
    v[2943] = -17.89;
    std::vector<double> res = hoarBatcherSeq(v, v.size());
    EXPECT_EQ(1, isSortCorrectly(res));
}

//  parallel part

TEST(PAR_hoar_batcher, can_hoar_batcher_sort_zero_vec) {
    std::vector<double> v{ 0, 0, 1, 0, 0, 0, 0, 0 };
    int size = v.size();
    std::vector<double> res = hoarBatcherPar(v, size);
    EXPECT_EQ(1, isSortCorrectly(res));
}

TEST(PAR_hoar_batcher, can_hoar_batcher_sort_vec_with_even_size) {
    int size = 400;
    std::vector<double> v = getRandVector(size);
    std::vector<double> res = hoarBatcherPar(v, v.size());
    EXPECT_EQ(1, isSortCorrectly(res));
}

TEST(PAR_hoar_batcher, can_hoar_batcher_sort_vec_with_odd_size) {
    int size = 1331;
    std::vector<double> v = getRandVector(size);
    std::vector<double> res = hoarBatcherPar(v, v.size());
    EXPECT_EQ(1, isSortCorrectly(res));
}

TEST(PAR_hoar_batcher, can_hoar_batcher_sort_vec_with_double_elem) {
    int size = 9081;
    std::vector<double> v = getRandVector(size);
    v[740] = 4.5691;
    v[2943] = -17.89;
    std::vector<double> res = hoarBatcherPar(v, v.size());
    EXPECT_EQ(1, isSortCorrectly(res));
}

TEST(PAR_hoar_batcher, compare_seq_seq_sort_with_vec_size_100) {
    int size = 100;
    std::vector<double> v = getRandVector(size);

    double start_time, seq_time, par_time;
    start_time = omp_get_wtime();
    std::vector<double> res_seq = hoarBatcherSeq(v, v.size());
    seq_time = omp_get_wtime() - start_time;

    start_time = omp_get_wtime();
    std::vector<double> res_par = hoarBatcherPar(v, v.size());
    par_time = omp_get_wtime() - start_time;

    std::cout << "res: " << par_time / seq_time;
    std::cout << " par: " << par_time;
    std::cout << " seq: " << seq_time;

    EXPECT_EQ(res_seq, res_par);
}

TEST(PAR_hoar_batcher, compare_seq_par_sort_with_vec_size_10000) {
    int size = 10000;
    std::vector<double> v = getRandVector(size);

    double start_time, seq_time, par_time;
    start_time = omp_get_wtime();
    std::vector<double> res_seq = hoarBatcherSeq(v, v.size());
    seq_time = omp_get_wtime() - start_time;

    start_time = omp_get_wtime();
    std::vector<double> res_par = hoarBatcherPar(v, v.size());
    par_time = omp_get_wtime() - start_time;

    std::cout << "res: " << par_time / seq_time;
    std::cout << " par: " << par_time;
    std::cout << " seq: " << seq_time;

    EXPECT_EQ(res_seq, res_par);
}

TEST(PAR_hoar_batcher, compare_seq_par_sort_with_vec_size_100000) {
    int size = 100000;
    std::vector<double> v = getRandVector(size);

    double start_time, seq_time, par_time;
    start_time = omp_get_wtime();
    std::vector<double> res_seq = hoarBatcherSeq(v, v.size());
    seq_time = omp_get_wtime() - start_time;

    start_time = omp_get_wtime();
    std::vector<double> res_par = hoarBatcherPar(v, v.size());
    par_time = omp_get_wtime() - start_time;

    std::cout << "res: " << par_time / seq_time;
    std::cout << " par: " << par_time;
    std::cout << " seq: " << seq_time;

    EXPECT_EQ(res_seq, res_par);
}

TEST(PAR_hoar_batcher, compare_seq_par_sort_with_vec_size_1000000) {
    int size = 1000000;
    std::vector<double> v = getRandVector(size);

    double start_time, seq_time, par_time;
    start_time = omp_get_wtime();
    std::vector<double> res_seq = hoarBatcherSeq(v, v.size());
    seq_time = omp_get_wtime() - start_time;

    start_time = omp_get_wtime();
    std::vector<double> res_par = hoarBatcherPar(v, v.size());
    par_time = omp_get_wtime() - start_time;

    std::cout << "res: " << par_time / seq_time;
    std::cout << " par: " << par_time;
    std::cout << " seq: " << seq_time;

    EXPECT_EQ(res_seq, res_par);
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}

\end{lstlisting}
\newpage

\textbf{STD версия}
\par hoar\_batcher.h
\begin{lstlisting}

// Copyright 2022 Remizova Antonina
#ifndef MODULES_TASK_4_REMIZOVA_A_HOAR_BATCHER_HOAR_BATCHER_H_
#define MODULES_TASK_4_REMIZOVA_A_HOAR_BATCHER_HOAR_BATCHER_H_

#include <random>
#include <vector>
#include <ctime>

std::vector<double> getRandVector(int size);
bool isSortCorrectly(const std::vector <double>& vec);
void hoarSort(std::vector <double>* vec, int left, int right);
std::vector<double> evenBatcherSort(const std::vector<double>& vec1, const std::vector<double>& vec2);
std::vector<double> oddBatcherSort(const std::vector<double>& vec1, const std::vector<double>& vec2);
std::vector<double> oddEvenBatcherSort(const std::vector<double>& vec1, const std::vector<double>& vec2);
std::vector<double> mergeBatcher(const std::vector<double>& vec, int middle);
std::vector<double> hoarBatcherSeq(const std::vector<double>& vec, int size);
std::vector<double> hoarBatcherPar(const std::vector<double>& vec, int size);

#endif  // MODULES_TASK_4_REMIZOVA_A_HOAR_BATCHER_HOAR_BATCHER_H_

\end{lstlisting}
\par hoar\_batcher.cpp
\begin{lstlisting}

// Copyright 2022 Remizova Antonina
#include "../../../modules/task_4/remizova_a_hoar_batcher/hoar_batcher.h"
#include <iostream>
#include <algorithm>
#include <random>
#include <vector>
#include "../../../3rdparty/unapproved/unapproved.h"

std::vector<double> getRandVector(int size) {
    if (size < 0)
        throw "negative vector size";

    std::mt19937 gen((unsigned int)time(0));
    std::uniform_int_distribution <int> dist(-100000, 100000);
    std::vector <double> vec(size);
    for (int i = 0; i < size; i++) {
        vec[i] = dist(gen);
    }
    return vec;
}

bool isSortCorrectly(const std::vector <double>& vec) {
    bool sort = std::is_sorted(vec.begin(), vec.end());
    return sort;
}

void hoarSort(std::vector <double>* vec, int l_ind, int r_ind) {
    if (l_ind >= r_ind)
        return;

    int l = l_ind, r = r_ind;
    double pvt = vec->at((l + r) / 2);

    while (l <= r) {
        while (vec->at(l) < pvt)
            l++;
        while (vec->at(r) > pvt)
            r--;
        if (l <= r) {
            std::swap(vec->at(l), vec->at(r));
            l++;
            r--;
        }
    }

    if (l < r_ind)
        hoarSort(vec, l, r_ind);
    if (l_ind < r)
        hoarSort(vec, l_ind, r);

    return;
}

std::vector<double> evenBatcherSort(const std::vector<double>& vec1, const std::vector<double>& vec2) {
    const int size_v1 = vec1.size();
    const int size_v2 = vec2.size();
    int i = 0, j = 0, k = 0, l = 0;
    const int size_eres = vec1.size() / 2 + vec2.size() / 2 + vec1.size() % 2 + vec2.size() % 2;
    std::vector<double> eres(size_eres);
    for (; i < size_v1 && j < size_v2; k++) {
        if (vec1[i] <= vec2[j]) {
            eres[k] = vec1[i];
            i += 2;
        } else {
            eres[k] = vec2[j];
            j += 2;
        }
    }
    if (i >= size_v1) {
        for (l = j; l < size_v2; l += 2, k++)
            eres[k] = vec2[l];
    } else {
        for (l = i; l < size_v1; l += 2, k++)
            eres[k] = vec1[l];
    }

    return eres;
}

std::vector<double> oddBatcherSort(const std::vector<double>& vec1, const std::vector<double>& vec2) {
    const int size_v1 = vec1.size();
    const int size_v2 = vec2.size();
    int i = 1, j = 1, k = 0, l = 0;
    const int size_ores = vec1.size() / 2 + vec2.size() / 2;
    std::vector<double> ores(size_ores);
    for (; i < size_v1 && j < size_v2; k++) {
        if (vec1[i] <= vec2[j]) {
            ores[k] = vec1[i];
            i += 2;
        } else {
            ores[k] = vec2[j];
            j += 2;
        }
    }
    if (i >= size_v1) {
        for (l = j; l < size_v2; l += 2, k++)
            ores[k] = vec2[l];
    } else {
        for (l = i; l < size_v1; l += 2, k++)
            ores[k] = vec1[l];
    }

    return ores;
}

std::vector<double> oddEvenBatcherSort(const std::vector<double>& vec1, const std::vector<double>& vec2) {
    int size_oeres = vec1.size() + vec2.size();
    std::vector<double> oeres(size_oeres);

    for (size_t i = 0; i < vec1.size(); i++)
        oeres[i] = vec1[i];

    for (int i = vec1.size(), j = 0; i < size_oeres; i++, j++)
        oeres[i] = vec2[j];

    return oeres;
}

std::vector<double> mergeBatcher(const std::vector<double>& vec, int middle) {
    int size_res = vec.size();
    std::vector <double> res(size_res);
    int buf;

    for (int i = 0; i < size_res - middle; i++) {
        res[i * 2] = vec[i];
        res[i * 2 + 1] = vec[middle + i];
    }

    if (middle * 2 - size_res >= 1)
        res[size_res - 1] = vec[middle - 1];

    if (middle * 2 - size_res == 2)
        res[size_res - 2] = vec[middle - 2];

    for (int i = 1; i < size_res; i++) {
        if (res[i] < res[i - 1]) {
            buf = res[i - 1];
            res[i - 1] = res[i];
            res[i] = buf;
        }
    }

    return res;
}

std::vector<double> hoarBatcherSeq(const std::vector<double>& vec, int size) {
    int k = size / 2;
    std::vector<double> vec1;
    vec1.assign(vec.begin(), vec.end() - k);
    std::vector<double> vec2;
    hoarSort(&vec1, 0, vec1.size() - 1);
    vec2.assign(vec.end() - k, vec.end());
    hoarSort(&vec2, 0, vec2.size() - 1);
    std::vector<double>even = evenBatcherSort(vec1, vec2);
    std::vector<double>odd = oddBatcherSort(vec1, vec2);
    std::vector<double>res_oe = oddEvenBatcherSort(even, odd);
    std::vector<double>sort_res = mergeBatcher(res_oe, even.size());
    return sort_res;
}

std::vector<double> hoarBatcherPar(const std::vector<double>& vec, int size) {
    int k = size / 2;
    std::vector<double> vec1;
    vec1.assign(vec.begin(), vec.end() - k);
    std::vector<double> vec2;
    vec2.assign(vec.end() - k, vec.end());
    std::vector<double>even;
    std::vector<double>odd;

    auto t1 = std::async(std::launch::async, hoarSort, &vec1, 0, vec1.size() - 1);
    auto t2 = std::async(std::launch::async, hoarSort, &vec2, 0, vec2.size() - 1);
    t1.wait();
    t2.wait();

    auto t3 = std::async(std::launch::async, evenBatcherSort, vec1, vec2);
    auto t4 = std::async(std::launch::async, oddBatcherSort, vec1, vec2);
    even = t3.get();
    odd = t4.get();

    std::vector<double>res_oe = oddEvenBatcherSort(even, odd);
    std::vector<double>sort_res = mergeBatcher(res_oe, even.size());
    return sort_res;
}

\end{lstlisting}
\par main.cpp
\begin{lstlisting}

// Copyright 2022 Remizova Antonina
#include <gtest/gtest.h>
#include "./hoar_batcher.h"

TEST(SEQ_hoar_batcher, can_create_rand_vec_10) {
    int size = 10;

    EXPECT_NO_THROW(getRandVector(size));
}

TEST(SEQ_hoar_batcher, can_create_rand_vec_10000) {
    int size = 10000;

    EXPECT_NO_THROW(getRandVector(size));
}

TEST(SEQ_hoar_batcher, can_not_create_rand_vec_with_negative_size) {
    int size = -10;

    EXPECT_ANY_THROW(getRandVector(size));
}

TEST(SEQ_hoar_batcher, can_hoar_sort_rand_vec) {
    int size = 231;
    std::vector<double> v = getRandVector(size);
    hoarSort(&v, 0, size - 1);
    EXPECT_EQ(1, isSortCorrectly(v));
}

TEST(SEQ_hoar_batcher, can_hoar_batcher_sort_zero_vec) {
    std::vector<double> v{ 0, 0, 1, 0, 0, 0, 0, 0 };
    int size = v.size();
    std::vector<double> res = hoarBatcherSeq(v, size);
    EXPECT_EQ(1, isSortCorrectly(res));
}

TEST(SEQ_hoar_batcher, can_hoar_batcher_sort_vec_with_even_size) {
    int size = 400;
    std::vector<double> v = getRandVector(size);
    std::vector<double> res = hoarBatcherSeq(v, v.size());
    EXPECT_EQ(1, isSortCorrectly(res));
}

TEST(SEQ_hoar_batcher, can_hoar_batcher_sort_vec_with_odd_size) {
    int size = 1331;
    std::vector<double> v = getRandVector(size);
    std::vector<double> res = hoarBatcherSeq(v, v.size());
    EXPECT_EQ(1, isSortCorrectly(res));
}

TEST(SEQ_hoar_batcher, can_hoar_batcher_sort_vec_with_double_elem) {
    int size = 9081;
    std::vector<double> v = getRandVector(size);
    v[740] = 4.5691;
    v[2943] = -17.89;
    std::vector<double> res = hoarBatcherSeq(v, v.size());
    EXPECT_EQ(1, isSortCorrectly(res));
}

//  parallel part

TEST(PAR_hoar_batcher, can_hoar_batcher_sort_zero_vec) {
    std::vector<double> v{ 0, 0, 1, 0, 0, 0, 0, 0 };
    int size = v.size();
    std::vector<double> res = hoarBatcherPar(v, size);
    EXPECT_EQ(1, isSortCorrectly(res));
}

TEST(PAR_hoar_batcher, can_hoar_batcher_sort_vec_with_even_size) {
    int size = 400;
    std::vector<double> v = getRandVector(size);
    std::vector<double> res = hoarBatcherPar(v, v.size());
    EXPECT_EQ(1, isSortCorrectly(res));
}

TEST(PAR_hoar_batcher, can_hoar_batcher_sort_vec_with_odd_size) {
    int size = 1331;
    std::vector<double> v = getRandVector(size);
    std::vector<double> res = hoarBatcherPar(v, v.size());
    EXPECT_EQ(1, isSortCorrectly(res));
}

TEST(PAR_hoar_batcher, can_hoar_batcher_sort_vec_with_double_elem) {
    int size = 9081;
    std::vector<double> v = getRandVector(size);
    v[740] = 4.5691;
    v[2943] = -17.89;
    std::vector<double> res = hoarBatcherPar(v, v.size());
    EXPECT_EQ(1, isSortCorrectly(res));
}

TEST(PAR_hoar_batcher, compare_seq_seq_sort_with_vec_size_100) {
    int size = 100;
    std::vector<double> v = getRandVector(size);

    clock_t t_start;

    t_start = clock();
    std::vector<double> res_seq = hoarBatcherSeq(v, v.size());
    auto seq_t = (clock() - t_start) / 1000.0;

    t_start = clock();
    std::vector<double> res_par = hoarBatcherSeq(v, v.size());
    auto par_t = (clock() - t_start) / 1000.0;

    std::cout << "res: " << par_t / seq_t;
    std::cout << " par: " << par_t;
    std::cout << " seq: " << seq_t;

    EXPECT_EQ(res_seq, res_par);
}

TEST(PAR_hoar_batcher, compare_seq_par_sort_with_vec_size_10000) {
    int size = 10000;
    std::vector<double> v = getRandVector(size);

    clock_t t_start;

    t_start = clock();
    std::vector<double> res_seq = hoarBatcherSeq(v, v.size());
    auto seq_t = (clock() - t_start) / 1000.0;

    t_start = clock();
    std::vector<double> res_par = hoarBatcherPar(v, v.size());
    auto par_t = (clock() - t_start) / 1000.0;

    std::cout << "res: " << par_t / seq_t;
    std::cout << " par: " << par_t;
    std::cout << " seq: " << seq_t;

    EXPECT_EQ(res_seq, res_par);
}

TEST(PAR_hoar_batcher, compare_seq_par_sort_with_vec_size_100000) {
    int size = 100000;
    std::vector<double> v = getRandVector(size);

    clock_t t_start;

    t_start = clock();
    std::vector<double> res_seq = hoarBatcherSeq(v, v.size());
    auto seq_t = (clock() - t_start) / 1000.0;

    t_start = clock();
    std::vector<double> res_par = hoarBatcherPar(v, v.size());
    auto par_t = (clock() - t_start) / 1000.0;

    std::cout << "res: " << par_t / seq_t;
    std::cout << " par: " << par_t;
    std::cout << " seq: " << seq_t;

    EXPECT_EQ(res_seq, res_par);
}

TEST(PAR_hoar_batcher, compare_seq_par_sort_with_vec_size_1000000) {
    int size = 1000000;
    std::vector<double> v = getRandVector(size);

    clock_t t_start;

    t_start = clock();
    std::vector<double> res_seq = hoarBatcherSeq(v, v.size());
    auto seq_t = (clock() - t_start) / 1000.0;

    t_start = clock();
    std::vector<double> res_par = hoarBatcherPar(v, v.size());
    auto par_t = (clock() - t_start) / 1000.0;

    std::cout << "res: " << par_t / seq_t;
    std::cout << " par: " << par_t;
    std::cout << " seq: " << seq_t;

    EXPECT_EQ(res_seq, res_par);
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}

\end{lstlisting}
\end{document}